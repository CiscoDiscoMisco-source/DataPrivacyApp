"use strict";
/*
 * ATTENTION: An "eval-source-map" devtool has been used.
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file with attached SourceMaps in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
self["webpackHotUpdate_N_E"]("app/global-preferences/page",{

/***/ "(app-pages-browser)/./src/services/dataService.ts":
/*!*************************************!*\
  !*** ./src/services/dataService.ts ***!
  \*************************************/
/***/ (function(module, __webpack_exports__, __webpack_require__) {

eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   dataService: function() { return /* binding */ dataService; }\n/* harmony export */ });\n/* __next_internal_client_entry_do_not_use__ dataService,default auto */ // Sample company data\nconst COMPANIES = [\n    {\n        id: \"1\",\n        name: \"TechCorp\",\n        logo: \"/logos/techcorp.png\",\n        industry: \"Technology\",\n        description: \"A leading technology company specializing in cloud services.\",\n        dataSharingPolicies: [\n            {\n                id: \"101\",\n                dataType: \"Personal Info\",\n                purpose: \"Account Management\",\n                thirdParties: [\n                    \"CustomerService Co.\",\n                    \"CloudSecurity Inc.\"\n                ],\n                description: \"Basic personal information used for account management and security.\"\n            },\n            {\n                id: \"102\",\n                dataType: \"Usage Data\",\n                purpose: \"Analytics\",\n                thirdParties: [\n                    \"Analytics Pro\",\n                    \"DataInsight Ltd.\"\n                ],\n                description: \"Information about how you use our services.\"\n            },\n            {\n                id: \"103\",\n                dataType: \"Location\",\n                purpose: \"Service Localization\",\n                thirdParties: [\n                    \"LocalSearch Inc.\"\n                ],\n                description: \"Your location data to provide local services.\"\n            }\n        ]\n    },\n    {\n        id: \"2\",\n        name: \"FinanceHub\",\n        logo: \"/logos/financehub.png\",\n        industry: \"Finance\",\n        description: \"Financial services and banking solutions.\",\n        dataSharingPolicies: [\n            {\n                id: \"201\",\n                dataType: \"Personal Info\",\n                purpose: \"Identity Verification\",\n                thirdParties: [\n                    \"VerifyID Inc.\",\n                    \"SecureCheck Corp.\"\n                ],\n                description: \"Verifying your identity for security and regulatory compliance.\"\n            },\n            {\n                id: \"202\",\n                dataType: \"Financial Data\",\n                purpose: \"Transaction Processing\",\n                thirdParties: [\n                    \"PaymentProcess Ltd.\",\n                    \"CreditCheck Co.\"\n                ],\n                description: \"Processing your financial transactions and credit history.\"\n            },\n            {\n                id: \"203\",\n                dataType: \"Location\",\n                purpose: \"Fraud Detection\",\n                thirdParties: [\n                    \"FraudShield Inc.\"\n                ],\n                description: \"Detecting unusual activity patterns for your security.\"\n            }\n        ]\n    },\n    {\n        id: \"3\",\n        name: \"HealthPlus\",\n        logo: \"/logos/healthplus.png\",\n        industry: \"Healthcare\",\n        description: \"Healthcare services and wellness solutions.\",\n        dataSharingPolicies: [\n            {\n                id: \"301\",\n                dataType: \"Personal Info\",\n                purpose: \"Patient Registration\",\n                thirdParties: [\n                    \"MedicalRecords Inc.\"\n                ],\n                description: \"Managing your patient information for better service.\"\n            },\n            {\n                id: \"302\",\n                dataType: \"Health Data\",\n                purpose: \"Treatment\",\n                thirdParties: [\n                    \"SpecialistNet\",\n                    \"LabResults Ltd.\"\n                ],\n                description: \"Health information used for diagnosis and treatment.\"\n            },\n            {\n                id: \"303\",\n                dataType: \"Insurance Info\",\n                purpose: \"Billing\",\n                thirdParties: [\n                    \"InsuranceBilling Co.\"\n                ],\n                description: \"Insurance details for processing claims and payments.\"\n            }\n        ]\n    }\n];\n// Default preferences (all disallowed initially)\nconst defaultPreferences = [\n    // Global preferences\n    {\n        id: \"g1\",\n        dataType: \"Personal Info\",\n        allowed: false\n    },\n    {\n        id: \"g2\",\n        dataType: \"Usage Data\",\n        allowed: false\n    },\n    {\n        id: \"g3\",\n        dataType: \"Location\",\n        allowed: false\n    },\n    {\n        id: \"g4\",\n        dataType: \"Financial Data\",\n        allowed: false\n    },\n    {\n        id: \"g5\",\n        dataType: \"Health Data\",\n        allowed: false\n    },\n    {\n        id: \"g6\",\n        dataType: \"Insurance Info\",\n        allowed: false\n    }\n];\n// Default user\nconst DEFAULT_USER = {\n    id: \"user1\",\n    email: \"user@example.com\",\n    name: \"Demo User\",\n    tokens: 10\n};\n// Token packages\nconst TOKEN_PACKAGES = [\n    {\n        id: \"basic\",\n        name: \"Basic Pack\",\n        amount: 10,\n        price: 4.99,\n        description: \"Basic token pack with 10 tokens\"\n    },\n    {\n        id: \"standard\",\n        name: \"Standard Pack\",\n        amount: 50,\n        price: 19.99,\n        description: \"Standard token pack with 50 tokens\"\n    },\n    {\n        id: \"premium\",\n        name: \"Premium Pack\",\n        amount: 200,\n        price: 49.99,\n        description: \"Premium token pack with 200 tokens, best value\"\n    }\n];\n// Local storage keys\nconst COMPANIES_KEY = \"data-privacy-companies\";\nconst PREFERENCES_KEY = \"data-privacy-preferences\";\nconst USER_KEY = \"data-privacy-user\";\nconst preferenceChangeListeners = [];\nconst dataService = {\n    // Get all companies\n    getCompanies: ()=>{\n        if (false) {}\n        const storedCompanies = localStorage.getItem(COMPANIES_KEY);\n        if (!storedCompanies) {\n            localStorage.setItem(COMPANIES_KEY, JSON.stringify(COMPANIES));\n            return COMPANIES;\n        }\n        return JSON.parse(storedCompanies);\n    },\n    // Get a specific company\n    getCompany: (id)=>{\n        const companies = dataService.getCompanies();\n        return companies.find((company)=>company.id === id);\n    },\n    // Get all preferences\n    getPreferences: ()=>{\n        if (false) {}\n        const storedPreferences = localStorage.getItem(PREFERENCES_KEY);\n        if (!storedPreferences) {\n            localStorage.setItem(PREFERENCES_KEY, JSON.stringify(defaultPreferences));\n            return defaultPreferences;\n        }\n        return JSON.parse(storedPreferences);\n    },\n    // Get global preferences\n    getGlobalPreferences: ()=>{\n        const preferences = dataService.getPreferences();\n        return preferences.filter((pref)=>!pref.companyId);\n    },\n    // Get company-specific preferences\n    getCompanyPreferences: (companyId)=>{\n        const preferences = dataService.getPreferences();\n        return preferences.filter((pref)=>pref.companyId === companyId);\n    },\n    // Save a preference\n    savePreference: (preference)=>{\n        if (false) {}\n        const preferences = dataService.getPreferences();\n        // Find if preference already exists\n        const index = preferences.findIndex((p)=>p.dataType === preference.dataType && p.companyId === preference.companyId);\n        if (index >= 0) {\n            // Update existing preference\n            preferences[index] = preference;\n        } else {\n            // Add new preference\n            preferences.push(preference);\n        }\n        // Save to localStorage\n        localStorage.setItem(PREFERENCES_KEY, JSON.stringify(preferences));\n        // Notify listeners\n        dataService.notifyPreferenceChange();\n    },\n    // Clone preferences from one company to another\n    clonePreferences: (sourceCompanyId, targetCompanyId)=>{\n        if (false) {}\n        const preferences = dataService.getPreferences();\n        const sourcePreferences = preferences.filter((pref)=>pref.companyId === sourceCompanyId);\n        // Get target company to ensure we clone only relevant data types\n        const targetCompany = dataService.getCompany(targetCompanyId);\n        if (!targetCompany) return;\n        // Get the list of data types actually used by the target company\n        const targetCompanyDataTypes = targetCompany.dataSharingPolicies.map((policy)=>policy.dataType);\n        if (sourcePreferences.length === 0) {\n            // If no source preferences found, check if we should use global preferences\n            const globalPrefs = preferences.filter((pref)=>!pref.companyId);\n            if (globalPrefs.length > 0) {\n                // Create new preferences for target company based on global preferences\n                // But only for data types that are actually used by the target company\n                const targetPreferences = globalPrefs.filter((pref)=>targetCompanyDataTypes.includes(pref.dataType)).map((pref)=>({\n                        id: \"\".concat(targetCompanyId, \"-\").concat(pref.dataType.replace(/\\s+/g, \"-\").toLowerCase()),\n                        dataType: pref.dataType,\n                        allowed: pref.allowed,\n                        companyId: targetCompanyId\n                    }));\n                // Remove any existing preferences for the target company\n                const filteredPreferences = preferences.filter((pref)=>pref.companyId !== targetCompanyId);\n                // Add new preferences\n                const updatedPreferences = [\n                    ...filteredPreferences,\n                    ...targetPreferences\n                ];\n                // Save to localStorage\n                localStorage.setItem(PREFERENCES_KEY, JSON.stringify(updatedPreferences));\n                // Notify listeners\n                dataService.notifyPreferenceChange();\n            }\n            return;\n        }\n        // Create a map of source preferences for quick lookup\n        const sourcePrefsMap = new Map();\n        sourcePreferences.forEach((pref)=>{\n            sourcePrefsMap.set(pref.dataType, pref);\n        });\n        // Create new preferences for target company, but only for data types they use\n        const targetPreferences = [];\n        // Ensure we create a preference for each data type in the target company\n        targetCompany.dataSharingPolicies.forEach((policy)=>{\n            const sourcePref = sourcePrefsMap.get(policy.dataType);\n            // Use the source preference if available, otherwise use global preference\n            const globalPref = preferences.find((p)=>p.dataType === policy.dataType && !p.companyId);\n            const allowed = sourcePref ? sourcePref.allowed : globalPref ? globalPref.allowed : false;\n            targetPreferences.push({\n                id: \"\".concat(targetCompanyId, \"-\").concat(policy.dataType.replace(/\\s+/g, \"-\").toLowerCase()),\n                dataType: policy.dataType,\n                allowed: allowed,\n                companyId: targetCompanyId\n            });\n        });\n        // Remove any existing preferences for the target company\n        const filteredPreferences = preferences.filter((pref)=>pref.companyId !== targetCompanyId);\n        // Add new preferences\n        const updatedPreferences = [\n            ...filteredPreferences,\n            ...targetPreferences\n        ];\n        // Save to localStorage\n        localStorage.setItem(PREFERENCES_KEY, JSON.stringify(updatedPreferences));\n        // Notify listeners\n        dataService.notifyPreferenceChange();\n    },\n    // Get effective preference (taking into account global and company-specific)\n    getEffectivePreference: (dataType, companyId)=>{\n        const preferences = dataService.getPreferences();\n        // Check for company-specific preference\n        const companyPref = preferences.find((p)=>p.dataType === dataType && p.companyId === companyId);\n        if (companyPref) {\n            return companyPref.allowed;\n        }\n        // Fall back to global preference\n        const globalPref = preferences.find((p)=>p.dataType === dataType && !p.companyId);\n        return globalPref ? globalPref.allowed : false;\n    },\n    // Subscribe to preference changes\n    subscribeToPreferenceChanges: (listener)=>{\n        preferenceChangeListeners.push(listener);\n        // Return unsubscribe function\n        return ()=>{\n            const index = preferenceChangeListeners.indexOf(listener);\n            if (index > -1) {\n                preferenceChangeListeners.splice(index, 1);\n            }\n        };\n    },\n    // Notify all listeners of preference changes\n    notifyPreferenceChange: ()=>{\n        preferenceChangeListeners.forEach((listener)=>listener());\n    },\n    // User and token methods\n    getUser: ()=>{\n        if (false) {}\n        const storedUser = localStorage.getItem(USER_KEY);\n        if (!storedUser) {\n            localStorage.setItem(USER_KEY, JSON.stringify(DEFAULT_USER));\n            return DEFAULT_USER;\n        }\n        return JSON.parse(storedUser);\n    },\n    getTokenPackages: ()=>{\n        return TOKEN_PACKAGES;\n    },\n    purchaseTokens: (packageId)=>{\n        const tokenPackage = TOKEN_PACKAGES.find((pkg)=>pkg.id === packageId);\n        if (!tokenPackage) return false;\n        const user = dataService.getUser();\n        user.tokens += tokenPackage.amount;\n        localStorage.setItem(USER_KEY, JSON.stringify(user));\n        return true;\n    },\n    hasEnoughTokens: (amount)=>{\n        const user = dataService.getUser();\n        return user.tokens >= amount;\n    },\n    spendTokens: (amount)=>{\n        if (!dataService.hasEnoughTokens(amount)) return false;\n        const user = dataService.getUser();\n        user.tokens -= amount;\n        localStorage.setItem(USER_KEY, JSON.stringify(user));\n        return true;\n    },\n    // Calculate token cost for preference changes\n    calculatePreferenceCost: (preferences)=>{\n        // Group preferences by whether they're global or company-specific\n        const globalPrefs = [];\n        const companyPrefs = {};\n        preferences.forEach((pref)=>{\n            if (!pref.companyId) {\n                globalPrefs.push(pref);\n            } else {\n                if (!companyPrefs[pref.companyId]) {\n                    companyPrefs[pref.companyId] = [];\n                }\n                companyPrefs[pref.companyId].push(pref);\n            }\n        });\n        // Calculate cost\n        let totalCost = 0;\n        // Company-specific preferences: 1 token per data type\n        Object.values(companyPrefs).forEach((prefs)=>{\n            totalCost += prefs.length;\n        });\n        // Global preferences: 1 token per data type × number of companies\n        if (globalPrefs.length > 0) {\n            const companies = dataService.getCompanies();\n            totalCost += globalPrefs.length * companies.length;\n        }\n        return totalCost;\n    },\n    savePreferencesWithTokens: (preferences)=>{\n        const cost = dataService.calculatePreferenceCost(preferences);\n        // Check if user has enough tokens\n        if (!dataService.hasEnoughTokens(cost)) {\n            return false;\n        }\n        // Spend tokens\n        dataService.spendTokens(cost);\n        // Save preferences\n        preferences.forEach((preference)=>{\n            dataService.savePreference(preference);\n        });\n        return true;\n    }\n};\n/* harmony default export */ __webpack_exports__[\"default\"] = (dataService);\n\n\n;\n    // Wrapped in an IIFE to avoid polluting the global scope\n    ;\n    (function () {\n        var _a, _b;\n        // Legacy CSS implementations will `eval` browser code in a Node.js context\n        // to extract CSS. For backwards compatibility, we need to check we're in a\n        // browser context before continuing.\n        if (typeof self !== 'undefined' &&\n            // AMP / No-JS mode does not inject these helpers:\n            '$RefreshHelpers$' in self) {\n            // @ts-ignore __webpack_module__ is global\n            var currentExports = module.exports;\n            // @ts-ignore __webpack_module__ is global\n            var prevSignature = (_b = (_a = module.hot.data) === null || _a === void 0 ? void 0 : _a.prevSignature) !== null && _b !== void 0 ? _b : null;\n            // This cannot happen in MainTemplate because the exports mismatch between\n            // templating and execution.\n            self.$RefreshHelpers$.registerExportsForReactRefresh(currentExports, module.id);\n            // A module can be accepted automatically based on its exports, e.g. when\n            // it is a Refresh Boundary.\n            if (self.$RefreshHelpers$.isReactRefreshBoundary(currentExports)) {\n                // Save the previous exports signature on update so we can compare the boundary\n                // signatures. We avoid saving exports themselves since it causes memory leaks (https://github.com/vercel/next.js/pull/53797)\n                module.hot.dispose(function (data) {\n                    data.prevSignature =\n                        self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports);\n                });\n                // Unconditionally accept an update to this module, we'll check if it's\n                // still a Refresh Boundary later.\n                // @ts-ignore importMeta is replaced in the loader\n                module.hot.accept();\n                // This field is set when the previous version of this module was a\n                // Refresh Boundary, letting us know we need to check for invalidation or\n                // enqueue an update.\n                if (prevSignature !== null) {\n                    // A boundary can become ineligible if its exports are incompatible\n                    // with the previous exports.\n                    //\n                    // For example, if you add/remove/change exports, we'll want to\n                    // re-execute the importing modules, and force those components to\n                    // re-render. Similarly, if you convert a class component to a\n                    // function, we want to invalidate the boundary.\n                    if (self.$RefreshHelpers$.shouldInvalidateReactRefreshBoundary(prevSignature, self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports))) {\n                        module.hot.invalidate();\n                    }\n                    else {\n                        self.$RefreshHelpers$.scheduleUpdate();\n                    }\n                }\n            }\n            else {\n                // Since we just executed the code for the module, it's possible that the\n                // new exports made it ineligible for being a boundary.\n                // We only care about the case when we were _previously_ a boundary,\n                // because we already accepted this update (accidental side effect).\n                var isNoLongerABoundary = prevSignature !== null;\n                if (isNoLongerABoundary) {\n                    module.hot.invalidate();\n                }\n            }\n        }\n    })();\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL3NyYy9zZXJ2aWNlcy9kYXRhU2VydmljZS50cyIsIm1hcHBpbmdzIjoiOzs7O3lFQU1BLHNCQUFzQjtBQUN0QixNQUFNQSxZQUF1QjtJQUMzQjtRQUNFQyxJQUFJO1FBQ0pDLE1BQU07UUFDTkMsTUFBTTtRQUNOQyxVQUFVO1FBQ1ZDLGFBQWE7UUFDYkMscUJBQXFCO1lBQ25CO2dCQUNFTCxJQUFJO2dCQUNKTSxVQUFVO2dCQUNWQyxTQUFTO2dCQUNUQyxjQUFjO29CQUFDO29CQUF1QjtpQkFBcUI7Z0JBQzNESixhQUFhO1lBQ2Y7WUFDQTtnQkFDRUosSUFBSTtnQkFDSk0sVUFBVTtnQkFDVkMsU0FBUztnQkFDVEMsY0FBYztvQkFBQztvQkFBaUI7aUJBQW1CO2dCQUNuREosYUFBYTtZQUNmO1lBQ0E7Z0JBQ0VKLElBQUk7Z0JBQ0pNLFVBQVU7Z0JBQ1ZDLFNBQVM7Z0JBQ1RDLGNBQWM7b0JBQUM7aUJBQW1CO2dCQUNsQ0osYUFBYTtZQUNmO1NBQ0Q7SUFDSDtJQUNBO1FBQ0VKLElBQUk7UUFDSkMsTUFBTTtRQUNOQyxNQUFNO1FBQ05DLFVBQVU7UUFDVkMsYUFBYTtRQUNiQyxxQkFBcUI7WUFDbkI7Z0JBQ0VMLElBQUk7Z0JBQ0pNLFVBQVU7Z0JBQ1ZDLFNBQVM7Z0JBQ1RDLGNBQWM7b0JBQUM7b0JBQWlCO2lCQUFvQjtnQkFDcERKLGFBQWE7WUFDZjtZQUNBO2dCQUNFSixJQUFJO2dCQUNKTSxVQUFVO2dCQUNWQyxTQUFTO2dCQUNUQyxjQUFjO29CQUFDO29CQUF1QjtpQkFBa0I7Z0JBQ3hESixhQUFhO1lBQ2Y7WUFDQTtnQkFDRUosSUFBSTtnQkFDSk0sVUFBVTtnQkFDVkMsU0FBUztnQkFDVEMsY0FBYztvQkFBQztpQkFBbUI7Z0JBQ2xDSixhQUFhO1lBQ2Y7U0FDRDtJQUNIO0lBQ0E7UUFDRUosSUFBSTtRQUNKQyxNQUFNO1FBQ05DLE1BQU07UUFDTkMsVUFBVTtRQUNWQyxhQUFhO1FBQ2JDLHFCQUFxQjtZQUNuQjtn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QWUsQ0FBQ1MsT0FBTztZQUN0QyxPQUFPO1FBQ1Q7UUFFQSxlQUFlO1FBQ2YxRSxZQUFZa0UsV0FBVyxDQUFDUTtRQUV4QixtQkFBbUI7UUFDbkIxRCxZQUFZOEIsT0FBTyxDQUFDeEIsQ0FBQUE7WUFDbEJ0QixZQUFZcUIsY0FBYyxDQUFDQztRQUM3QjtRQUVBLE9BQU87SUFDVDtBQUNGLEVBQUU7QUFFRiwrREFBZXRCLFdBQVdBLEVBQUMiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9fTl9FLy4vc3JjL3NlcnZpY2VzL2RhdGFTZXJ2aWNlLnRzPzA4NDciXSwic291cmNlc0NvbnRlbnQiOlsiJ3VzZSBjbGllbnQnO1xuXG5pbXBvcnQgeyBDb21wYW55LCBEYXRhU2hhcmluZ1BvbGljeSB9IGZyb20gJ0AvbW9kZWxzL2NvbXBhbnknO1xuaW1wb3J0IHsgUHJlZmVyZW5jZSB9IGZyb20gJ0AvbW9kZWxzL3ByZWZlcmVuY2UnO1xuaW1wb3J0IHsgVXNlciwgVG9rZW5QYWNrYWdlIH0gZnJvbSAnQC9tb2RlbHMvdXNlcic7XG5cbi8vIFNhbXBsZSBjb21wYW55IGRhdGFcbmNvbnN0IENPTVBBTklFUzogQ29tcGFueVtdID0gW1xuICB7XG4gICAgaWQ6ICcxJyxcbiAgICBuYW1lOiAnVGVjaENvcnAnLFxuICAgIGxvZ286ICcvbG9nb3MvdGVjaGNvcnAucG5nJyxcbiAgICBpbmR1c3RyeTogJ1RlY2hub2xvZ3knLFxuICAgIGRlc2NyaXB0aW9uOiAnQSBsZWFkaW5nIHRlY2hub2xvZ3kgY29tcGFueSBzcGVjaWFsaXppbmcgaW4gY2xvdWQgc2VydmljZXMuJyxcbiAgICBkYXRhU2hhcmluZ1BvbGljaWVzOiBbXG4gICAgICB7XG4gICAgICAgIGlkOiAnMTAxJyxcbiAgICAgICAgZGF0YVR5cGU6ICdQZXJzb25hbCBJbmZvJyxcbiAgICAgICAgcHVycG9zZTogJ0FjY291bnQgTWFuYWdlbWVudCcsXG4gICAgICAgIHRoaXJkUGFydGllczogWydDdXN0b21lclNlcnZpY2UgQ28uJywgJ0Nsb3VkU2VjdXJpdHkgSW5jLiddLFxuICAgICAgICBkZXNjcmlwdGlvbjogJ0Jhc2ljIHBlcnNvbmFsIGluZm9ybWF0aW9uIHVzZWQgZm9yIGFjY291bnQgbWFuYWdlbWVudCBhbmQgc2VjdXJpdHkuJ1xuICAgICAgfSxcbiAgICAgIHtcbiAgICAgICAgaWQ6ICcxMDInLFxuICAgICAgICBkYXRhVHlwZTogJ1VzYWdlIERhdGEnLFxuICAgICAgICBwdXJwb3NlOiAnQW5hbHl0aWNzJyxcbiAgICAgICAgdGhpcmRQYXJ0aWVzOiBbJ0FuYWx5dGljcyBQcm8nLCAnRGF0YUluc2lnaHQgTHRkLiddLFxuICAgICAgICBkZXNjcmlwdGlvbjogJ0luZm9ybWF0aW9uIGFib3V0IGhvdyB5b3UgdXNlIG91ciBzZXJ2aWNlcy4nXG4gICAgICB9LFxuICAgICAge1xuICAgICAgICBpZDogJzEwMycsXG4gICAgICAgIGRhdGFUeXBlOiAnTG9jYXRpb24nLFxuICAgICAgICBwdXJwb3NlOiAnU2VydmljZSBMb2NhbGl6YXRpb24nLFxuICAgICAgICB0aGlyZFBhcnRpZXM6IFsnTG9jYWxTZWFyY2ggSW5jLiddLFxuICAgICAgICBkZXNjcmlwdGlvbjogJ1lvdXIgbG9jYXRpb24gZGF0YSB0byBwcm92aWRlIGxvY2FsIHNlcnZpY2VzLidcbiAgICAgIH1cbiAgICBdXG4gIH0sXG4gIHtcbiAgICBpZDogJzInLFxuICAgIG5hbWU6ICdGaW5hbmNlSHViJyxcbiAgICBsb2dvOiAnL2xvZ29zL2ZpbmFuY2VodWIucG5nJyxcbiAgICBpbmR1c3RyeTogJ0ZpbmFuY2UnLFxuICAgIGRlc2NyaXB0aW9uOiAnRmluYW5jaWFsIHNlcnZpY2VzIGFuZCBiYW5raW5nIHNvbHV0aW9ucy4nLFxuICAgIGRhdGFTaGFyaW5nUG9saWNpZXM6IFtcbiAgICAgIHtcbiAgICAgICAgaWQ6ICcyMDEnLFxuICAgICAgICBkYXRhVHlwZTogJ1BlcnNvbmFsIEluZm8nLFxuICAgICAgICBwdXJwb3NlOiAnSWRlbnRpdHkgVmVyaWZpY2F0aW9uJyxcbiAgICAgICAgdGhpcmRQYXJ0aWVzOiBbJ1ZlcmlmeUlEIEluYy4nLCAnU2VjdXJlQ2hlY2sgQ29ycC4nXSxcbiAgICAgICAgZGVzY3JpcHRpb246ICdWZXJpZnlpbmcgeW91ciBpZGVudGl0eSBmb3Igc2VjdXJpdHkgYW5kIHJlZ3VsYXRvcnkgY29tcGxpYW5jZS4nXG4gICAgICB9LFxuICAgICAge1xuICAgICAgICBpZDogJzIwMicsXG4gICAgICAgIGRhdGFUeXBlOiAnRmluYW5jaWFsIERhdGEnLFxuICAgICAgICBwdXJwb3NlOiAnVHJhbnNhY3Rpb24gUHJvY2Vzc2luZycsXG4gICAgICAgIHRoaXJkUGFydGllczogWydQYXltZW50UHJvY2VzcyBMdGQuJywgJ0NyZWRpdENoZWNrIENvLiddLFxuICAgICAgICBkZXNjcmlwdGlvbjogJ1Byb2Nlc3NpbmcgeW91ciBmaW5hbmNpYWwgdHJhbnNhY3Rpb25zIGFuZCBjcmVkaXQgaGlzdG9yeS4nXG4gICAgICB9LFxuICAgICAge1xuICAgICAgICBpZDogJzIwMycsXG4gICAgICAgIGRhdGFUeXBlOiAnTG9jYXRpb24nLFxuICAgICAgICBwdXJwb3NlOiAnRnJhdWQgRGV0ZWN0aW9uJyxcbiAgICAgICAgdGhpcmRQYXJ0aWVzOiBbJ0ZyYXVkU2hpZWxkIEluYy4nXSxcbiAgICAgICAgZGVzY3JpcHRpb246ICdEZXRlY3RpbmcgdW51c3VhbCBhY3Rpdml0eSBwYXR0ZXJucyBmb3IgeW91ciBzZWN1cml0eS4nXG4gICAgICB9XG4gICAgXVxuICB9LFxuICB7XG4gICAgaWQ6ICczJyxcbiAgICBuYW1lOiAnSGVhbHRoUGx1cycsXG4gICAgbG9nbzogJy9sb2dvcy9oZWFsdGhwbHVzLnBuZycsXG4gICAgaW5kdXN0cnk6ICdIZWFsdGhjYXJlJyxcbiAgICBkZXNjcmlwdGlvbjogJ0hlYWx0aGNhcmUgc2VydmljZXMgYW5kIHdlbGxuZXNzIHNvbHV0aW9ucy4nLFxuICAgIGRhdGFTaGFyaW5nUG9saWNpZXM6IFtcbiAgICAgIHtcbiAgICAgICAgaWQ6ICczMDEnLFxuICAgICAgICBkYXRhVHlwZTogJ1BlcnNvbmFsIEluZm8nLFxuICAgICAgICBwdXJwb3NlOiAnUGF0aWVudCBSZWdpc3RyYXRpb24nLFxuICAgICAgICB0aGlyZFBhcnRpZXM6IFsnTWVkaWNhbFJlY29yZHMgSW5jLiddLFxuICAgICAgICBkZXNjcmlwdGlvbjogJ01hbmFnaW5nIHlvdXIgcGF0aWVudCBpbmZvcm1hdGlvbiBmb3IgYmV0dGVyIHNlcnZpY2UuJ1xuICAgICAgfSxcbiAgICAgIHtcbiAgICAgICAgaWQ6ICczMDInLFxuICAgICAgICBkYXRhVHlwZTogJ0hlYWx0aCBEYXRhJyxcbiAgICAgICAgcHVycG9zZTogJ1RyZWF0bWVudCcsXG4gICAgICAgIHRoaXJkUGFydGllczogWydTcGVjaWFsaXN0TmV0JywgJ0xhYlJlc3VsdHMgTHRkLiddLFxuICAgICAgICBkZXNjcmlwdGlvbjogJ0hlYWx0aCBpbmZvcm1hdGlvbiB1c2VkIGZvciBkaWFnbm9zaXMgYW5kIHRyZWF0bWVudC4nXG4gICAgICB9LFxuICAgICAge1xuICAgICAgICBpZDogJzMwMycsXG4gICAgICAgIGRhdGFUeXBlOiAnSW5zdXJhbmNlIEluZm8nLFxuICAgICAgICBwdXJwb3NlOiAnQmlsbGluZycsXG4gICAgICAgIHRoaXJkUGFydGllczogWydJbnN1cmFuY2VCaWxsaW5nIENvLiddLFxuICAgICAgICBkZXNjcmlwdGlvbjogJ0luc3VyYW5jZSBkZXRhaWxzIGZvciBwcm9jZXNzaW5nIGNsYWltcyBhbmQgcGF5bWVudHMuJ1xuICAgICAgfVxuICAgIF1cbiAgfVxuXTtcblxuLy8gRGVmYXVsdCBwcmVmZXJlbmNlcyAoYWxsIGRpc2FsbG93ZWQgaW5pdGlhbGx5KVxuY29uc3QgZGVmYXVsdFByZWZlcmVuY2VzOiBQcmVmZXJlbmNlW10gPSBbXG4gIC8vIEdsb2JhbCBwcmVmZXJlbmNlc1xuICB7IGlkOiAnZzEnLCBkYXRhVHlwZTogJ1BlcnNvbmFsIEluZm8nLCBhbGxvd2VkOiBmYWxzZSB9LFxuICB7IGlkOiAnZzInLCBkYXRhVHlwZTogJ1VzYWdlIERhdGEnLCBhbGxvd2VkOiBmYWxzZSB9LFxuICB7IGlkOiAnZzMnLCBkYXRhVHlwZTogJ0xvY2F0aW9uJywgYWxsb3dlZDogZmFsc2UgfSxcbiAgeyBpZDogJ2c0JywgZGF0YVR5cGU6ICdGaW5hbmNpYWwgRGF0YScsIGFsbG93ZWQ6IGZhbHNlIH0sXG4gIHsgaWQ6ICdnNScsIGRhdGFUeXBlOiAnSGVhbHRoIERhdGEnLCBhbGxvd2VkOiBmYWxzZSB9LFxuICB7IGlkOiAnZzYnLCBkYXRhVHlwZTogJ0luc3VyYW5jZSBJbmZvJywgYWxsb3dlZDogZmFsc2UgfVxuXTtcblxuLy8gRGVmYXVsdCB1c2VyXG5jb25zdCBERUZBVUxUX1VTRVI6IFVzZXIgPSB7XG4gIGlkOiAndXNlcjEnLFxuICBlbWFpbDogJ3VzZXJAZXhhbXBsZS5jb20nLFxuICBuYW1lOiAnRGVtbyBVc2VyJyxcbiAgdG9rZW5zOiAxMFxufTtcblxuLy8gVG9rZW4gcGFja2FnZXNcbmNvbnN0IFRPS0VOX1BBQ0tBR0VTOiBUb2tlblBhY2thZ2VbXSA9IFtcbiAge1xuICAgIGlkOiAnYmFzaWMnLFxuICAgIG5hbWU6ICdCYXNpYyBQYWNrJyxcbiAgICBhbW91bnQ6IDEwLFxuICAgIHByaWNlOiA0Ljk5LFxuICAgIGRlc2NyaXB0aW9uOiAnQmFzaWMgdG9rZW4gcGFjayB3aXRoIDEwIHRva2VucydcbiAgfSxcbiAge1xuICAgIGlkOiAnc3RhbmRhcmQnLFxuICAgIG5hbWU6ICdTdGFuZGFyZCBQYWNrJyxcbiAgICBhbW91bnQ6IDUwLFxuICAgIHByaWNlOiAxOS45OSxcbiAgICBkZXNjcmlwdGlvbjogJ1N0YW5kYXJkIHRva2VuIHBhY2sgd2l0aCA1MCB0b2tlbnMnXG4gIH0sXG4gIHtcbiAgICBpZDogJ3ByZW1pdW0nLFxuICAgIG5hbWU6ICdQcmVtaXVtIFBhY2snLFxuICAgIGFtb3VudDogMjAwLFxuICAgIHByaWNlOiA0OS45OSxcbiAgICBkZXNjcmlwdGlvbjogJ1ByZW1pdW0gdG9rZW4gcGFjayB3aXRoIDIwMCB0b2tlbnMsIGJlc3QgdmFsdWUnXG4gIH1cbl07XG5cbi8vIExvY2FsIHN0b3JhZ2Uga2V5c1xuY29uc3QgQ09NUEFOSUVTX0tFWSA9ICdkYXRhLXByaXZhY3ktY29tcGFuaWVzJztcbmNvbnN0IFBSRUZFUkVOQ0VTX0tFWSA9ICdkYXRhLXByaXZhY3ktcHJlZmVyZW5jZXMnO1xuY29uc3QgVVNFUl9LRVkgPSAnZGF0YS1wcml2YWN5LXVzZXInO1xuXG4vLyBFdmVudCBlbWl0dGVyIGZvciBwcmVmZXJlbmNlIGNoYW5nZXNcbnR5cGUgUHJlZmVyZW5jZUNoYW5nZUxpc3RlbmVyID0gKCkgPT4gdm9pZDtcbmNvbnN0IHByZWZlcmVuY2VDaGFuZ2VMaXN0ZW5lcnM6IFByZWZlcmVuY2VDaGFuZ2VMaXN0ZW5lcltdID0gW107XG5cbmV4cG9ydCBjb25zdCBkYXRhU2VydmljZSA9IHtcbiAgLy8gR2V0IGFsbCBjb21wYW5pZXNcbiAgZ2V0Q29tcGFuaWVzOiAoKTogQ29tcGFueVtdID0+IHtcbiAgICBpZiAodHlwZW9mIHdpbmRvdyA9PT0gJ3VuZGVmaW5lZCcpIHJldHVybiBDT01QQU5JRVM7XG4gICAgXG4gICAgY29uc3Qgc3RvcmVkQ29tcGFuaWVzID0gbG9jYWxTdG9yYWdlLmdldEl0ZW0oQ09NUEFOSUVTX0tFWSk7XG4gICAgaWYgKCFzdG9yZWRDb21wYW5pZXMpIHtcbiAgICAgIGxvY2FsU3RvcmFnZS5zZXRJdGVtKENPTVBBTklFU19LRVksIEpTT04uc3RyaW5naWZ5KENPTVBBTklFUykpO1xuICAgICAgcmV0dXJuIENPTVBBTklFUztcbiAgICB9XG4gICAgXG4gICAgcmV0dXJuIEpTT04ucGFyc2Uoc3RvcmVkQ29tcGFuaWVzKTtcbiAgfSxcbiAgXG4gIC8vIEdldCBhIHNwZWNpZmljIGNvbXBhbnlcbiAgZ2V0Q29tcGFueTogKGlkOiBzdHJpbmcpOiBDb21wYW55IHwgdW5kZWZpbmVkID0+IHtcbiAgICBjb25zdCBjb21wYW5pZXMgPSBkYXRhU2VydmljZS5nZXRDb21wYW5pZXMoKTtcbiAgICByZXR1cm4gY29tcGFuaWVzLmZpbmQoY29tcGFueSA9PiBjb21wYW55LmlkID09PSBpZCk7XG4gIH0sXG4gIFxuICAvLyBHZXQgYWxsIHByZWZlcmVuY2VzXG4gIGdldFByZWZlcmVuY2VzOiAoKTogUHJlZmVyZW5jZVtdID0+IHtcbiAgICBpZiAodHlwZW9mIHdpbmRvdyA9PT0gJ3VuZGVmaW5lZCcpIHJldHVybiBkZWZhdWx0UHJlZmVyZW5jZXM7XG4gICAgXG4gICAgY29uc3Qgc3RvcmVkUHJlZmVyZW5jZXMgPSBsb2NhbFN0b3JhZ2UuZ2V0SXRlbShQUkVGRVJFTkNFU19LRVkpO1xuICAgIGlmICghc3RvcmVkUHJlZmVyZW5jZXMpIHtcbiAgICAgIGxvY2FsU3RvcmFnZS5zZXRJdGVtKFBSRUZFUkVOQ0VTX0tFWSwgSlNPTi5zdHJpbmdpZnkoZGVmYXVsdFByZWZlcmVuY2VzKSk7XG4gICAgICByZXR1cm4gZGVmYXVsdFByZWZlcmVuY2VzO1xuICAgIH1cbiAgICBcbiAgICByZXR1cm4gSlNPTi5wYXJzZShzdG9yZWRQcmVmZXJlbmNlcyk7XG4gIH0sXG4gIFxuICAvLyBHZXQgZ2xvYmFsIHByZWZlcmVuY2VzXG4gIGdldEdsb2JhbFByZWZlcmVuY2VzOiAoKTogUHJlZmVyZW5jZVtdID0+IHtcbiAgICBjb25zdCBwcmVmZXJlbmNlcyA9IGRhdGFTZXJ2aWNlLmdldFByZWZlcmVuY2VzKCk7XG4gICAgcmV0dXJuIHByZWZlcmVuY2VzLmZpbHRlcihwcmVmID0+ICFwcmVmLmNvbXBhbnlJZCk7XG4gIH0sXG4gIFxuICAvLyBHZXQgY29tcGFueS1zcGVjaWZpYyBwcmVmZXJlbmNlc1xuICBnZXRDb21wYW55UHJlZmVyZW5jZXM6IChjb21wYW55SWQ6IHN0cmluZyk6IFByZWZlcmVuY2VbXSA9PiB7XG4gICAgY29uc3QgcHJlZmVyZW5jZXMgPSBkYXRhU2VydmljZS5nZXRQcmVmZXJlbmNlcygpO1xuICAgIHJldHVybiBwcmVmZXJlbmNlcy5maWx0ZXIocHJlZiA9PiBwcmVmLmNvbXBhbnlJZCA9PT0gY29tcGFueUlkKTtcbiAgfSxcbiAgXG4gIC8vIFNhdmUgYSBwcmVmZXJlbmNlXG4gIHNhdmVQcmVmZXJlbmNlOiAocHJlZmVyZW5jZTogUHJlZmVyZW5jZSk6IHZvaWQgPT4ge1xuICAgIGlmICh0eXBlb2Ygd2luZG93ID09PSAndW5kZWZpbmVkJykgcmV0dXJuO1xuICAgIFxuICAgIGNvbnN0IHByZWZlcmVuY2VzID0gZGF0YVNlcnZpY2UuZ2V0UHJlZmVyZW5jZXMoKTtcbiAgICBcbiAgICAvLyBGaW5kIGlmIHByZWZlcmVuY2UgYWxyZWFkeSBleGlzdHNcbiAgICBjb25zdCBpbmRleCA9IHByZWZlcmVuY2VzLmZpbmRJbmRleChcbiAgICAgIHAgPT4gcC5kYXRhVHlwZSA9PT0gcHJlZmVyZW5jZS5kYXRhVHlwZSAmJiBcbiAgICAgIHAuY29tcGFueUlkID09PSBwcmVmZXJlbmNlLmNvbXBhbnlJZFxuICAgICk7XG4gICAgXG4gICAgaWYgKGluZGV4ID49IDApIHtcbiAgICAgIC8vIFVwZGF0ZSBleGlzdGluZyBwcmVmZXJlbmNlXG4gICAgICBwcmVmZXJlbmNlc1tpbmRleF0gPSBwcmVmZXJlbmNlO1xuICAgIH0gZWxzZSB7XG4gICAgICAvLyBBZGQgbmV3IHByZWZlcmVuY2VcbiAgICAgIHByZWZlcmVuY2VzLnB1c2gocHJlZmVyZW5jZSk7XG4gICAgfVxuICAgIFxuICAgIC8vIFNhdmUgdG8gbG9jYWxTdG9yYWdlXG4gICAgbG9jYWxTdG9yYWdlLnNldEl0ZW0oUFJFRkVSRU5DRVNfS0VZLCBKU09OLnN0cmluZ2lmeShwcmVmZXJlbmNlcykpO1xuICAgIFxuICAgIC8vIE5vdGlmeSBsaXN0ZW5lcnNcbiAgICBkYXRhU2VydmljZS5ub3RpZnlQcmVmZXJlbmNlQ2hhbmdlKCk7XG4gIH0sXG4gIFxuICAvLyBDbG9uZSBwcmVmZXJlbmNlcyBmcm9tIG9uZSBjb21wYW55IHRvIGFub3RoZXJcbiAgY2xvbmVQcmVmZXJlbmNlczogKHNvdXJjZUNvbXBhbnlJZDogc3RyaW5nLCB0YXJnZXRDb21wYW55SWQ6IHN0cmluZyk6IHZvaWQgPT4ge1xuICAgIGlmICh0eXBlb2Ygd2luZG93ID09PSAndW5kZWZpbmVkJykgcmV0dXJuO1xuICAgIFxuICAgIGNvbnN0IHByZWZlcmVuY2VzID0gZGF0YVNlcnZpY2UuZ2V0UHJlZmVyZW5jZXMoKTtcbiAgICBjb25zdCBzb3VyY2VQcmVmZXJlbmNlcyA9IHByZWZlcmVuY2VzLmZpbHRlcihwcmVmID0+IHByZWYuY29tcGFueUlkID09PSBzb3VyY2VDb21wYW55SWQpO1xuICAgIFxuICAgIC8vIEdldCB0YXJnZXQgY29tcGFueSB0byBlbnN1cmUgd2UgY2xvbmUgb25seSByZWxldmFudCBkYXRhIHR5cGVzXG4gICAgY29uc3QgdGFyZ2V0Q29tcGFueSA9IGRhdGFTZXJ2aWNlLmdldENvbXBhbnkodGFyZ2V0Q29tcGFueUlkKTtcbiAgICBpZiAoIXRhcmdldENvbXBhbnkpIHJldHVybjtcbiAgICBcbiAgICAvLyBHZXQgdGhlIGxpc3Qgb2YgZGF0YSB0eXBlcyBhY3R1YWxseSB1c2VkIGJ5IHRoZSB0YXJnZXQgY29tcGFueVxuICAgIGNvbnN0IHRhcmdldENvbXBhbnlEYXRhVHlwZXMgPSB0YXJnZXRDb21wYW55LmRhdGFTaGFyaW5nUG9saWNpZXMubWFwKFxuICAgICAgcG9saWN5ID0+IHBvbGljeS5kYXRhVHlwZVxuICAgICk7XG4gICAgXG4gICAgaWYgKHNvdXJjZVByZWZlcmVuY2VzLmxlbmd0aCA9PT0gMCkge1xuICAgICAgLy8gSWYgbm8gc291cmNlIHByZWZlcmVuY2VzIGZvdW5kLCBjaGVjayBpZiB3ZSBzaG91bGQgdXNlIGdsb2JhbCBwcmVmZXJlbmNlc1xuICAgICAgY29uc3QgZ2xvYmFsUHJlZnMgPSBwcmVmZXJlbmNlcy5maWx0ZXIocHJlZiA9PiAhcHJlZi5jb21wYW55SWQpO1xuICAgICAgXG4gICAgICBpZiAoZ2xvYmFsUHJlZnMubGVuZ3RoID4gMCkge1xuICAgICAgICAvLyBDcmVhdGUgbmV3IHByZWZlcmVuY2VzIGZvciB0YXJnZXQgY29tcGFueSBiYXNlZCBvbiBnbG9iYWwgcHJlZmVyZW5jZXNcbiAgICAgICAgLy8gQnV0IG9ubHkgZm9yIGRhdGEgdHlwZXMgdGhhdCBhcmUgYWN0dWFsbHkgdXNlZCBieSB0aGUgdGFyZ2V0IGNvbXBhbnlcbiAgICAgICAgY29uc3QgdGFyZ2V0UHJlZmVyZW5jZXMgPSBnbG9iYWxQcmVmc1xuICAgICAgICAgIC5maWx0ZXIocHJlZiA9PiB0YXJnZXRDb21wYW55RGF0YVR5cGVzLmluY2x1ZGVzKHByZWYuZGF0YVR5cGUpKVxuICAgICAgICAgIC5tYXAocHJlZiA9PiAoe1xuICAgICAgICAgICAgaWQ6IGAke3RhcmdldENvbXBhbnlJZH0tJHtwcmVmLmRhdGFUeXBlLnJlcGxhY2UoL1xccysvZywgJy0nKS50b0xvd2VyQ2FzZSgpfWAsXG4gICAgICAgICAgICBkYXRhVHlwZTogcHJlZi5kYXRhVHlwZSxcbiAgICAgICAgICAgIGFsbG93ZWQ6IHByZWYuYWxsb3dlZCxcbiAgICAgICAgICAgIGNvbXBhbnlJZDogdGFyZ2V0Q29tcGFueUlkXG4gICAgICAgICAgfSkpO1xuICAgICAgICBcbiAgICAgICAgLy8gUmVtb3ZlIGFueSBleGlzdGluZyBwcmVmZXJlbmNlcyBmb3IgdGhlIHRhcmdldCBjb21wYW55XG4gICAgICAgIGNvbnN0IGZpbHRlcmVkUHJlZmVyZW5jZXMgPSBwcmVmZXJlbmNlcy5maWx0ZXIocHJlZiA9PiBwcmVmLmNvbXBhbnlJZCAhPT0gdGFyZ2V0Q29tcGFueUlkKTtcbiAgICAgICAgXG4gICAgICAgIC8vIEFkZCBuZXcgcHJlZmVyZW5jZXNcbiAgICAgICAgY29uc3QgdXBkYXRlZFByZWZlcmVuY2VzID0gWy4uLmZpbHRlcmVkUHJlZmVyZW5jZXMsIC4uLnRhcmdldFByZWZlcmVuY2VzXTtcbiAgICAgICAgXG4gICAgICAgIC8vIFNhdmUgdG8gbG9jYWxTdG9yYWdlXG4gICAgICAgIGxvY2FsU3RvcmFnZS5zZXRJdGVtKFBSRUZFUkVOQ0VTX0tFWSwgSlNPTi5zdHJpbmdpZnkodXBkYXRlZFByZWZlcmVuY2VzKSk7XG4gICAgICAgIFxuICAgICAgICAvLyBOb3RpZnkgbGlzdGVuZXJzXG4gICAgICAgIGRhdGFTZXJ2aWNlLm5vdGlmeVByZWZlcmVuY2VDaGFuZ2UoKTtcbiAgICAgIH1cbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgXG4gICAgLy8gQ3JlYXRlIGEgbWFwIG9mIHNvdXJjZSBwcmVmZXJlbmNlcyBmb3IgcXVpY2sgbG9va3VwXG4gICAgY29uc3Qgc291cmNlUHJlZnNNYXAgPSBuZXcgTWFwPHN0cmluZywgUHJlZmVyZW5jZT4oKTtcbiAgICBzb3VyY2VQcmVmZXJlbmNlcy5mb3JFYWNoKHByZWYgPT4ge1xuICAgICAgc291cmNlUHJlZnNNYXAuc2V0KHByZWYuZGF0YVR5cGUsIHByZWYpO1xuICAgIH0pO1xuICAgIFxuICAgIC8vIENyZWF0ZSBuZXcgcHJlZmVyZW5jZXMgZm9yIHRhcmdldCBjb21wYW55LCBidXQgb25seSBmb3IgZGF0YSB0eXBlcyB0aGV5IHVzZVxuICAgIGNvbnN0IHRhcmdldFByZWZlcmVuY2VzOiBQcmVmZXJlbmNlW10gPSBbXTtcbiAgICBcbiAgICAvLyBFbnN1cmUgd2UgY3JlYXRlIGEgcHJlZmVyZW5jZSBmb3IgZWFjaCBkYXRhIHR5cGUgaW4gdGhlIHRhcmdldCBjb21wYW55XG4gICAgdGFyZ2V0Q29tcGFueS5kYXRhU2hhcmluZ1BvbGljaWVzLmZvckVhY2gocG9saWN5ID0+IHtcbiAgICAgIGNvbnN0IHNvdXJjZVByZWYgPSBzb3VyY2VQcmVmc01hcC5nZXQocG9saWN5LmRhdGFUeXBlKTtcbiAgICAgIFxuICAgICAgLy8gVXNlIHRoZSBzb3VyY2UgcHJlZmVyZW5jZSBpZiBhdmFpbGFibGUsIG90aGVyd2lzZSB1c2UgZ2xvYmFsIHByZWZlcmVuY2VcbiAgICAgIGNvbnN0IGdsb2JhbFByZWYgPSBwcmVmZXJlbmNlcy5maW5kKFxuICAgICAgICBwID0+IHAuZGF0YVR5cGUgPT09IHBvbGljeS5kYXRhVHlwZSAmJiAhcC5jb21wYW55SWRcbiAgICAgICk7XG4gICAgICBcbiAgICAgIGNvbnN0IGFsbG93ZWQgPSBzb3VyY2VQcmVmIFxuICAgICAgICA/IHNvdXJjZVByZWYuYWxsb3dlZCBcbiAgICAgICAgOiAoZ2xvYmFsUHJlZiA/IGdsb2JhbFByZWYuYWxsb3dlZCA6IGZhbHNlKTtcbiAgICAgIFxuICAgICAgdGFyZ2V0UHJlZmVyZW5jZXMucHVzaCh7XG4gICAgICAgIGlkOiBgJHt0YXJnZXRDb21wYW55SWR9LSR7cG9saWN5LmRhdGFUeXBlLnJlcGxhY2UoL1xccysvZywgJy0nKS50b0xvd2VyQ2FzZSgpfWAsXG4gICAgICAgIGRhdGFUeXBlOiBwb2xpY3kuZGF0YVR5cGUsXG4gICAgICAgIGFsbG93ZWQ6IGFsbG93ZWQsXG4gICAgICAgIGNvbXBhbnlJZDogdGFyZ2V0Q29tcGFueUlkXG4gICAgICB9KTtcbiAgICB9KTtcbiAgICBcbiAgICAvLyBSZW1vdmUgYW55IGV4aXN0aW5nIHByZWZlcmVuY2VzIGZvciB0aGUgdGFyZ2V0IGNvbXBhbnlcbiAgICBjb25zdCBmaWx0ZXJlZFByZWZlcmVuY2VzID0gcHJlZmVyZW5jZXMuZmlsdGVyKHByZWYgPT4gcHJlZi5jb21wYW55SWQgIT09IHRhcmdldENvbXBhbnlJZCk7XG4gICAgXG4gICAgLy8gQWRkIG5ldyBwcmVmZXJlbmNlc1xuICAgIGNvbnN0IHVwZGF0ZWRQcmVmZXJlbmNlcyA9IFsuLi5maWx0ZXJlZFByZWZlcmVuY2VzLCAuLi50YXJnZXRQcmVmZXJlbmNlc107XG4gICAgXG4gICAgLy8gU2F2ZSB0byBsb2NhbFN0b3JhZ2VcbiAgICBsb2NhbFN0b3JhZ2Uuc2V0SXRlbShQUkVGRVJFTkNFU19LRVksIEpTT04uc3RyaW5naWZ5KHVwZGF0ZWRQcmVmZXJlbmNlcykpO1xuICAgIFxuICAgIC8vIE5vdGlmeSBsaXN0ZW5lcnNcbiAgICBkYXRhU2VydmljZS5ub3RpZnlQcmVmZXJlbmNlQ2hhbmdlKCk7XG4gIH0sXG4gIFxuICAvLyBHZXQgZWZmZWN0aXZlIHByZWZlcmVuY2UgKHRha2luZyBpbnRvIGFjY291bnQgZ2xvYmFsIGFuZCBjb21wYW55LXNwZWNpZmljKVxuICBnZXRFZmZlY3RpdmVQcmVmZXJlbmNlOiAoZGF0YVR5cGU6IHN0cmluZywgY29tcGFueUlkOiBzdHJpbmcpOiBib29sZWFuID0+IHtcbiAgICBjb25zdCBwcmVmZXJlbmNlcyA9IGRhdGFTZXJ2aWNlLmdldFByZWZlcmVuY2VzKCk7XG4gICAgXG4gICAgLy8gQ2hlY2sgZm9yIGNvbXBhbnktc3BlY2lmaWMgcHJlZmVyZW5jZVxuICAgIGNvbnN0IGNvbXBhbnlQcmVmID0gcHJlZmVyZW5jZXMuZmluZChcbiAgICAgIHAgPT4gcC5kYXRhVHlwZSA9PT0gZGF0YVR5cGUgJiYgcC5jb21wYW55SWQgPT09IGNvbXBhbnlJZFxuICAgICk7XG4gICAgXG4gICAgaWYgKGNvbXBhbnlQcmVmKSB7XG4gICAgICByZXR1cm4gY29tcGFueVByZWYuYWxsb3dlZDtcbiAgICB9XG4gICAgXG4gICAgLy8gRmFsbCBiYWNrIHRvIGdsb2JhbCBwcmVmZXJlbmNlXG4gICAgY29uc3QgZ2xvYmFsUHJlZiA9IHByZWZlcmVuY2VzLmZpbmQoXG4gICAgICBwID0+IHAuZGF0YVR5cGUgPT09IGRhdGFUeXBlICYmICFwLmNvbXBhbnlJZFxuICAgICk7XG4gICAgXG4gICAgcmV0dXJuIGdsb2JhbFByZWYgPyBnbG9iYWxQcmVmLmFsbG93ZWQgOiBmYWxzZTtcbiAgfSxcbiAgXG4gIC8vIFN1YnNjcmliZSB0byBwcmVmZXJlbmNlIGNoYW5nZXNcbiAgc3Vic2NyaWJlVG9QcmVmZXJlbmNlQ2hhbmdlczogKGxpc3RlbmVyOiBQcmVmZXJlbmNlQ2hhbmdlTGlzdGVuZXIpOiAoKSA9PiB2b2lkID0+IHtcbiAgICBwcmVmZXJlbmNlQ2hhbmdlTGlzdGVuZXJzLnB1c2gobGlzdGVuZXIpO1xuICAgIFxuICAgIC8vIFJldHVybiB1bnN1YnNjcmliZSBmdW5jdGlvblxuICAgIHJldHVybiAoKSA9PiB7XG4gICAgICBjb25zdCBpbmRleCA9IHByZWZlcmVuY2VDaGFuZ2VMaXN0ZW5lcnMuaW5kZXhPZihsaXN0ZW5lcik7XG4gICAgICBpZiAoaW5kZXggPiAtMSkge1xuICAgICAgICBwcmVmZXJlbmNlQ2hhbmdlTGlzdGVuZXJzLnNwbGljZShpbmRleCwgMSk7XG4gICAgICB9XG4gICAgfTtcbiAgfSxcbiAgXG4gIC8vIE5vdGlmeSBhbGwgbGlzdGVuZXJzIG9mIHByZWZlcmVuY2UgY2hhbmdlc1xuICBub3RpZnlQcmVmZXJlbmNlQ2hhbmdlOiAoKTogdm9pZCA9PiB7XG4gICAgcHJlZmVyZW5jZUNoYW5nZUxpc3RlbmVycy5mb3JFYWNoKGxpc3RlbmVyID0+IGxpc3RlbmVyKCkpO1xuICB9LFxuXG4gIC8vIFVzZXIgYW5kIHRva2VuIG1ldGhvZHNcbiAgZ2V0VXNlcjogKCk6IFVzZXIgPT4ge1xuICAgIGlmICh0eXBlb2Ygd2luZG93ID09PSAndW5kZWZpbmVkJykgcmV0dXJuIERFRkFVTFRfVVNFUjtcbiAgICBcbiAgICBjb25zdCBzdG9yZWRVc2VyID0gbG9jYWxTdG9yYWdlLmdldEl0ZW0oVVNFUl9LRVkpO1xuICAgIGlmICghc3RvcmVkVXNlcikge1xuICAgICAgbG9jYWxTdG9yYWdlLnNldEl0ZW0oVVNFUl9LRVksIEpTT04uc3RyaW5naWZ5KERFRkFVTFRfVVNFUikpO1xuICAgICAgcmV0dXJuIERFRkFVTFRfVVNFUjtcbiAgICB9XG4gICAgXG4gICAgcmV0dXJuIEpTT04ucGFyc2Uoc3RvcmVkVXNlcik7XG4gIH0sXG4gIFxuICBnZXRUb2tlblBhY2thZ2VzOiAoKTogVG9rZW5QYWNrYWdlW10gPT4ge1xuICAgIHJldHVybiBUT0tFTl9QQUNLQUdFUztcbiAgfSxcbiAgXG4gIHB1cmNoYXNlVG9rZW5zOiAocGFja2FnZUlkOiBzdHJpbmcpOiBib29sZWFuID0+IHtcbiAgICBjb25zdCB0b2tlblBhY2thZ2UgPSBUT0tFTl9QQUNLQUdFUy5maW5kKHBrZyA9PiBwa2cuaWQgPT09IHBhY2thZ2VJZCk7XG4gICAgaWYgKCF0b2tlblBhY2thZ2UpIHJldHVybiBmYWxzZTtcbiAgICBcbiAgICBjb25zdCB1c2VyID0gZGF0YVNlcnZpY2UuZ2V0VXNlcigpO1xuICAgIHVzZXIudG9rZW5zICs9IHRva2VuUGFja2FnZS5hbW91bnQ7XG4gICAgXG4gICAgbG9jYWxTdG9yYWdlLnNldEl0ZW0oVVNFUl9LRVksIEpTT04uc3RyaW5naWZ5KHVzZXIpKTtcbiAgICByZXR1cm4gdHJ1ZTtcbiAgfSxcbiAgXG4gIGhhc0Vub3VnaFRva2VuczogKGFtb3VudDogbnVtYmVyKTogYm9vbGVhbiA9PiB7XG4gICAgY29uc3QgdXNlciA9IGRhdGFTZXJ2aWNlLmdldFVzZXIoKTtcbiAgICByZXR1cm4gdXNlci50b2tlbnMgPj0gYW1vdW50O1xuICB9LFxuICBcbiAgc3BlbmRUb2tlbnM6IChhbW91bnQ6IG51bWJlcik6IGJvb2xlYW4gPT4ge1xuICAgIGlmICghZGF0YVNlcnZpY2UuaGFzRW5vdWdoVG9rZW5zKGFtb3VudCkpIHJldHVybiBmYWxzZTtcbiAgICBcbiAgICBjb25zdCB1c2VyID0gZGF0YVNlcnZpY2UuZ2V0VXNlcigpO1xuICAgIHVzZXIudG9rZW5zIC09IGFtb3VudDtcbiAgICBcbiAgICBsb2NhbFN0b3JhZ2Uuc2V0SXRlbShVU0VSX0tFWSwgSlNPTi5zdHJpbmdpZnkodXNlcikpO1xuICAgIHJldHVybiB0cnVlO1xuICB9LFxuICBcbiAgLy8gQ2FsY3VsYXRlIHRva2VuIGNvc3QgZm9yIHByZWZlcmVuY2UgY2hhbmdlc1xuICBjYWxjdWxhdGVQcmVmZXJlbmNlQ29zdDogKHByZWZlcmVuY2VzOiBQcmVmZXJlbmNlW10pOiBudW1iZXIgPT4ge1xuICAgIC8vIEdyb3VwIHByZWZlcmVuY2VzIGJ5IHdoZXRoZXIgdGhleSdyZSBnbG9iYWwgb3IgY29tcGFueS1zcGVjaWZpY1xuICAgIGNvbnN0IGdsb2JhbFByZWZzOiBQcmVmZXJlbmNlW10gPSBbXTtcbiAgICBjb25zdCBjb21wYW55UHJlZnM6IFJlY29yZDxzdHJpbmcsIFByZWZlcmVuY2VbXT4gPSB7fTtcbiAgICBcbiAgICBwcmVmZXJlbmNlcy5mb3JFYWNoKHByZWYgPT4ge1xuICAgICAgaWYgKCFwcmVmLmNvbXBhbnlJZCkge1xuICAgICAgICBnbG9iYWxQcmVmcy5wdXNoKHByZWYpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgaWYgKCFjb21wYW55UHJlZnNbcHJlZi5jb21wYW55SWRdKSB7XG4gICAgICAgICAgY29tcGFueVByZWZzW3ByZWYuY29tcGFueUlkXSA9IFtdO1xuICAgICAgICB9XG4gICAgICAgIGNvbXBhbnlQcmVmc1twcmVmLmNvbXBhbnlJZF0ucHVzaChwcmVmKTtcbiAgICAgIH1cbiAgICB9KTtcbiAgICBcbiAgICAvLyBDYWxjdWxhdGUgY29zdFxuICAgIGxldCB0b3RhbENvc3QgPSAwO1xuICAgIFxuICAgIC8vIENvbXBhbnktc3BlY2lmaWMgcHJlZmVyZW5jZXM6IDEgdG9rZW4gcGVyIGRhdGEgdHlwZVxuICAgIE9iamVjdC52YWx1ZXMoY29tcGFueVByZWZzKS5mb3JFYWNoKHByZWZzID0+IHtcbiAgICAgIHRvdGFsQ29zdCArPSBwcmVmcy5sZW5ndGg7XG4gICAgfSk7XG4gICAgXG4gICAgLy8gR2xvYmFsIHByZWZlcmVuY2VzOiAxIHRva2VuIHBlciBkYXRhIHR5cGUgw5cgbnVtYmVyIG9mIGNvbXBhbmllc1xuICAgIGlmIChnbG9iYWxQcmVmcy5sZW5ndGggPiAwKSB7XG4gICAgICBjb25zdCBjb21wYW5pZXMgPSBkYXRhU2VydmljZS5nZXRDb21wYW5pZXMoKTtcbiAgICAgIHRvdGFsQ29zdCArPSBnbG9iYWxQcmVmcy5sZW5ndGggKiBjb21wYW5pZXMubGVuZ3RoO1xuICAgIH1cbiAgICBcbiAgICByZXR1cm4gdG90YWxDb3N0O1xuICB9LFxuICBcbiAgc2F2ZVByZWZlcmVuY2VzV2l0aFRva2VuczogKHByZWZlcmVuY2VzOiBQcmVmZXJlbmNlW10pOiBib29sZWFuID0+IHtcbiAgICBjb25zdCBjb3N0ID0gZGF0YVNlcnZpY2UuY2FsY3VsYXRlUHJlZmVyZW5jZUNvc3QocHJlZmVyZW5jZXMpO1xuICAgIFxuICAgIC8vIENoZWNrIGlmIHVzZXIgaGFzIGVub3VnaCB0b2tlbnNcbiAgICBpZiAoIWRhdGFTZXJ2aWNlLmhhc0Vub3VnaFRva2Vucyhjb3N0KSkge1xuICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cbiAgICBcbiAgICAvLyBTcGVuZCB0b2tlbnNcbiAgICBkYXRhU2VydmljZS5zcGVuZFRva2Vucyhjb3N0KTtcbiAgICBcbiAgICAvLyBTYXZlIHByZWZlcmVuY2VzXG4gICAgcHJlZmVyZW5jZXMuZm9yRWFjaChwcmVmZXJlbmNlID0+IHtcbiAgICAgIGRhdGFTZXJ2aWNlLnNhdmVQcmVmZXJlbmNlKHByZWZlcmVuY2UpO1xuICAgIH0pO1xuICAgIFxuICAgIHJldHVybiB0cnVlO1xuICB9XG59O1xuXG5leHBvcnQgZGVmYXVsdCBkYXRhU2VydmljZTsgIl0sIm5hbWVzIjpbIkNPTVBBTklFUyIsImlkIiwibmFtZSIsImxvZ28iLCJpbmR1c3RyeSIsImRlc2NyaXB0aW9uIiwiZGF0YVNoYXJpbmdQb2xpY2llcyIsImRhdGFUeXBlIiwicHVycG9zZSIsInRoaXJkUGFydGllcyIsImRlZmF1bHRQcmVmZXJlbmNlcyIsImFsbG93ZWQiLCJERUZBVUxUX1VTRVIiLCJlbWFpbCIsInRva2VucyIsIlRPS0VOX1BBQ0tBR0VTIiwiYW1vdW50IiwicHJpY2UiLCJDT01QQU5JRVNfS0VZIiwiUFJFRkVSRU5DRVNfS0VZIiwiVVNFUl9LRVkiLCJwcmVmZXJlbmNlQ2hhbmdlTGlzdGVuZXJzIiwiZGF0YVNlcnZpY2UiLCJnZXRDb21wYW5pZXMiLCJzdG9yZWRDb21wYW5pZXMiLCJsb2NhbFN0b3JhZ2UiLCJnZXRJdGVtIiwic2V0SXRlbSIsIkpTT04iLCJzdHJpbmdpZnkiLCJwYXJzZSIsImdldENvbXBhbnkiLCJjb21wYW5pZXMiLCJmaW5kIiwiY29tcGFueSIsImdldFByZWZlcmVuY2VzIiwic3RvcmVkUHJlZmVyZW5jZXMiLCJnZXRHbG9iYWxQcmVmZXJlbmNlcyIsInByZWZlcmVuY2VzIiwiZmlsdGVyIiwicHJlZiIsImNvbXBhbnlJZCIsImdldENvbXBhbnlQcmVmZXJlbmNlcyIsInNhdmVQcmVmZXJlbmNlIiwicHJlZmVyZW5jZSIsImluZGV4IiwiZmluZEluZGV4IiwicCIsInB1c2giLCJub3RpZnlQcmVmZXJlbmNlQ2hhbmdlIiwiY2xvbmVQcmVmZXJlbmNlcyIsInNvdXJjZUNvbXBhbnlJZCIsInRhcmdldENvbXBhbnlJZCIsInNvdXJjZVByZWZlcmVuY2VzIiwidGFyZ2V0Q29tcGFueSIsInRhcmdldENvbXBhbnlEYXRhVHlwZXMiLCJtYXAiLCJwb2xpY3kiLCJsZW5ndGgiLCJnbG9iYWxQcmVmcyIsInRhcmdldFByZWZlcmVuY2VzIiwiaW5jbHVkZXMiLCJyZXBsYWNlIiwidG9Mb3dlckNhc2UiLCJmaWx0ZXJlZFByZWZlcmVuY2VzIiwidXBkYXRlZFByZWZlcmVuY2VzIiwic291cmNlUHJlZnNNYXAiLCJNYXAiLCJmb3JFYWNoIiwic2V0Iiwic291cmNlUHJlZiIsImdldCIsImdsb2JhbFByZWYiLCJnZXRFZmZlY3RpdmVQcmVmZXJlbmNlIiwiY29tcGFueVByZWYiLCJzdWJzY3JpYmVUb1ByZWZlcmVuY2VDaGFuZ2VzIiwibGlzdGVuZXIiLCJpbmRleE9mIiwic3BsaWNlIiwiZ2V0VXNlciIsInN0b3JlZFVzZXIiLCJnZXRUb2tlblBhY2thZ2VzIiwicHVyY2hhc2VUb2tlbnMiLCJwYWNrYWdlSWQiLCJ0b2tlblBhY2thZ2UiLCJwa2ciLCJ1c2VyIiwiaGFzRW5vdWdoVG9rZW5zIiwic3BlbmRUb2tlbnMiLCJjYWxjdWxhdGVQcmVmZXJlbmNlQ29zdCIsImNvbXBhbnlQcmVmcyIsInRvdGFsQ29zdCIsIk9iamVjdCIsInZhbHVlcyIsInByZWZzIiwic2F2ZVByZWZlcmVuY2VzV2l0aFRva2VucyIsImNvc3QiXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(app-pages-browser)/./src/services/dataService.ts\n"));

/***/ })

});